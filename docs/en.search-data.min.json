[{"id":0,"href":"/react-signup/Berichte/","title":"Berichte","parent":"Startseite","content":"Hier finden sich alle Berichte über dieses Projekt in \u0026ldquo;chronologisch absteigender\u0026rdquo; Reihenfolge. Das heißt: Die aktuellsten Berichte sind ganz oben, die älteren weiter unten.\nDoku-Seite automatisieren    2021-12-16 06:50:    Ich habe mit Hilfe von Python invoke den Prozess automatisiert, neue Doku mit Hugo zu generieren und dann im Hauptprojekt hochzuladen. Das shutils package war dabei ausgesprochen nützlich und hilfreich.\nEinrichten der Doku-Seite    2021-12-15 07:51:    Ja, es ist mir gestern abend tatsächlich gelungen, Hauptprojekt und Doku-Projekt erfolgreich zusammen zu bringen. Nun sollte ich berichten, wie ich das geschafft habe (nach viel Try And Error):\n  Die Sammelwebsite https://mt-lampert.github.io/ einrichten wie in der offiziellen Dokumentation beschrieben. Das ist nötig, um der Dokumentation eine \u0026ldquo;Heimat\u0026rdquo; im Web zu geben.\n  Im Hauptprojekt den Ordner docs einrichten. Dort werden die statischen Webseiten der Dokumentation abgespeichert.\n  Im Hauptprojekt den Git-Branch DOKU anlegen. Der wird im weiteren Verlauf noch sehr wichtig werden.\n  Im Hauptprojekt Die Doku-Seite nach Anweisung der offiziellen Dokumentation anlegen.\n benutzter Branch: DOKU(deshalb wurde er eingerichtet) benutztes Verzeichnis: docs (deshalb wurde auch das eingerichtet)    Im Doku-Projekt die Dokumentation bis zur \u0026ldquo;ersten Veröffentlichungsreife\u0026rdquo; anlegen, committen und pushen.\n  Im Doku-Projekt folgende Änderung in config.toml vornehmen, committen und pushen:\nbaseURL = \u0026#39;https://mt-lampert.github.io/react-signup/\u0026#39; languageCode = \u0026#39;de-de\u0026#39; title = \u0026#39;React Signup Documentation\u0026#39; Damit werden beim Kompilieren alle internen Links auf die baseURL \u0026ldquo;geeicht\u0026rdquo; und kommen da an, wo man sie erwartet.\n  Die Dokumentation mit Hilfe von Hugo neu rendern:\n# alle moeglichen Altlasten vermeiden $ rm -rf public/* # rendern! $ hugo   Im Hauptprojekt in den Branch DOKU wechseln:\n$ git checkout -b DOKU   Im Hauptprojekt den Inhalt des public-Verzeichnisses aus dem Doku-Verzeichnis nach /docs kopieren:\n$ rm -rf docs/* $ cp -R -f ../react-signup-documentation/public/* docs/   committen und pushen.\n  Das Ergebnis im Browser überprüfen\n  Im Hauptprojekt den DOKU-Branch verlassen.\n  Erste Erfolgsmeldung    2021-12-14 \u0026ndash; 20:23    Es ist mir, glaube ich gelungen, Hauptprojekt und Doku-Projekt erfolgreich zusammen zu bringen. Macht mich sehr stolz und glücklich!\n"},{"id":1,"href":"/react-signup/Reflexion/","title":"Reflexion","parent":"Startseite","content":"Diese Rubrik dient der Erklärung, warum ich bestimmte Sachen so mache und so entscheide, wie ich es tue. Denn Dokumentation ist für mich beides: Werkstattbericht und Reflexion. Der Werkstattbericht klärt darüber auf, was ich wann getan habe, die Reflexion klärt auf, warum.\nIn diesem Sinne: Möge uns diese Seite uns allen zum Gewinn reichen!\n"},{"id":2,"href":"/react-signup/Planung/testing/","title":"Testing","parent":"Planung","content":"Die wichtigste Regel:\n Testen muss geplant sein!\n Einfach drauf los und alles testen, was Beine hat \u0026ndash; so funktioniert es nicht! Was funktioniert, ist dort testen, wo wir uns unsicher fühlen: Neue Features, State-Updates, DOM-Updates usw.\nUnit-Tests, wo wir nur einzelne Components testen, werden wir aller Wahrscheinlichkeit nach nicht brauchen. Was wir ganz sicher brauchen, sind Integrations-Tests. Dort pruefen wir, wie gut ein Parent-Component mit seinen Child-Components zusammenarbeitet und harmoniert: Ob props in den Child-Components richtig umgesetzt werden, ob Binding richtig funktioniert, ob State-Updates auch auf dem Bildschirm die gewünschten Resultate liefern.\nWie müssen wir uns einen Integrations-Test vorstellen? In der Regel läuft er nach folgendem Schema ab:\n Das Parent-Component wird gerendert. Dabei wird ein virtuelles window.document, d.h. ein DOM im Speicher aufgebaut \u0026ndash; so wie im Browser; nur bleibt dieses window.document vollständig im Speicher und wird nicht im Browser angezeigt. Mit Hilfe von screen werden Node-Elemente aus window.document ausgewählt. Die ausgewählten Node-Elemente werden mit Hilfe von Events verändert. Dadurch ändert sich auch der Inhalt von window.document. Jetzt werden erneut Node-Elemente aus window.document mit Hilfe von screen ausgewählt \u0026ndash; nämlich die, bei denen wir erwarten, dass die Events von gerade eben sie in eine bestimmte Richtung verändert haben (Neue Werte, neue Formatierung, vielleicht sogar Auftauchen oder Verschwinden) Mit Hilfe von expect() überprüfen wir nun, ob sich die Änderungen tatsächlich wie erwünscht eingestellt haben oder nicht.  Grafisch sieht das etwa so aus:\n  graph TD A[render] --|init| L{window.document} L -- B(screen) B --|gets| D(el-1) B --|gets| E(el-2) B --|gets| F(el-3) D --|fireEvent| G{update document} E --|fireEvent| G F --|fireEvent| G G --H(screen) H --|gets Elements| I(expect) I --|checks elements| J{show Result}  Vollständiges Beispiel    Das folgende Beispiel nimmt neue Einträge in einer To-Do-App vor und überprüft, ob sie wie erwartet in der To-Do-Liste angezeigt werden:\n// Datei: Todo.spec.js import { render, screen, fireEvent } from \u0026#34;@testing-library/react\u0026#34;; import Todo from \u0026#34;../Todo\u0026#34;; import { BrowserRouter } from \u0026#34;react-router-dom\u0026#34;; // Wir brauchen dieses Component, weil in einem Child-Component von // \u0026lt;Todo /\u0026gt; Routing stattfindet. Dem muessen wir Rechnung tragen. const MockTodo = () =\u0026gt; { return ( \u0026lt;BrowserRouter\u0026gt; \u0026lt;Todo /\u0026gt; \u0026lt;/BrowserRouter\u0026gt; ); }; /** * @func addTask Helfer-Funktion, mit der man neue Eintraege in die To-Do-Liste simulieren kann. * @arg tasks Array mit neuen Eintraegen fuer die ToDo-Liste */ const addTask = (tasks) =\u0026gt; { // `screen` waehlt Elemente immer aus dem jetzt aktuellen window.document aus.  // nach einem Rendering werden sich dort hoffentlich entsprechende Elemente finden.  const inputElement = screen.getByPlaceholderText(/Add a new task here.../i); const buttonElement = screen.getByRole(\u0026#34;button\u0026#34;, { name: /Add/i }); tasks.forEach((task) =\u0026gt; { // Change-Event fuer inputElement ausloesen  // und task in target.value eintragen  fireEvent.change(inputElement, { target: { value: task } }); // Click-Event fuer buttonElement ausloesen  fireEvent.click(buttonElement); }); }; it(\u0026#34;creates new todo list item after adding one in the add component\u0026#34;, () =\u0026gt; { // \u0026lt;MockTodo /\u0026gt; wird gerendert und window.document initialisiert  render(\u0026lt;MockTodo /\u0026gt;); // Neuer Eintrag in die Todo-Liste =\u0026gt; update von window.document  addTask([\u0026#34;Go Grocery Shopping\u0026#34;]); // Auswahl des Node-Elements, das sich durch addTask geaendert hat  const divElement = screen.getByText(/Go Grocery Shopping/i); // Test: Ist es im DOM vorhanden oder nicht?  expect(divElement).toBeInTheDocument(); }); it(\u0026#34;adds multiple items of same kind if added in a likewise way\u0026#34;, () =\u0026gt; { // \u0026lt;MockTodo /\u0026gt; wird gerendert und window.document initialisiert  render(\u0026lt;MockTodo /\u0026gt;); // Drei identische neue Eintraege in die Todo-Liste =\u0026gt; update von window.document  addTask([ \u0026#34;Go Grocery Shopping\u0026#34;, \u0026#34;Go Grocery Shopping\u0026#34;, \u0026#34;Go Grocery Shopping\u0026#34;, ]); // Auswahl des Node-Elements, das sich durch addTask geaendert hat  const divElements = screen.queryAllByText(/Go Grocery Shopping/i); // Test: Haben die drei identischen Eintraege tatsaechlich zu drei identischen  // Eintraegen in der ToDo-Liste gefuehrt?  expect(divElements.length).toBe(3); }); it(\u0026#34;creates a new todo list entry without \u0026#39;todo-item-done\u0026#39; class\u0026#34;, () =\u0026gt; { // \u0026lt;MockTodo /\u0026gt; wird gerendert und window.document initialisiert  render(\u0026lt;MockTodo /\u0026gt;); // Neuer Eintrag in die Todo-Liste =\u0026gt; update von window.document  addTask([\u0026#34;Go Grocery Shopping\u0026#34;]); // Auswahl des Node-Elements, das sich durch addTask geaendert hat  const divElement = screen.getByText(/Go Grocery Shopping/i); // Test: FEHLT divElement tatsaechlich die CSS-Klasse \u0026#34;todo-item-active\u0026#34;?  expect(divElement).not.toHaveClass(\u0026#34;todo-item-done\u0026#34;); }); it(\u0026#34;adds the \u0026#39;todo-item-done\u0026#39; class to a todo list item when clicked\u0026#34;, () =\u0026gt; { // \u0026lt;MockTodo /\u0026gt; wird gerendert und window.document initialisiert  render(\u0026lt;MockTodo /\u0026gt;); // Neuer Eintrag in die Todo-Liste =\u0026gt; update von window.document  addTask([\u0026#34;Go Grocery Shopping\u0026#34;]); // Auswahl des Node-Elements, das sich durch addTask geaendert hat  const divElement = screen.getByText(/Go Grocery Shopping/i); // Click auf `divElement` simulieren  fireEvent.click(divElement); // Test: wurde die CSS-Klasse \u0026#34;todo-item-active\u0026#34;  // fuer `divElement` tatsaechlich hinzugefuegt?  expect(divElement).toHaveClass(\u0026#34;todo-item-done\u0026#34;); }); "},{"id":3,"href":"/react-signup/Reflexion/warum-test-driven/","title":"Warum Test-Driven Development?","parent":"Reflexion","content":"Ganz einfach, weil man dadurch Zeit spart! Bei einem automatisierten Test kann man z.B. Formularfelder automatisch vom Test-Generator ausfüllen lassen, danach den Submit-Button automatisch klicken lassen und daraufhin das neu gerenderte Ergebnis testen.\nBeim nächsten Test kann man das Formular dann mit anderen Einträgen automatisch ausfüllen lassen, danach den Submit-Button wieder automatisch klicken lassen und daraufhin ein anderes neu gerendertes Ergebnis testen. Und deshalb will ich Zeit investieren, um diese Sorte Test zu lernen \u0026ndash; damit ich hinterher umso mehr Zeit einsparen kann.\nWas genau sollten wir testen?    Die goldene Regel besagt: Teste nur das, was du selber implementiert hast \u0026ndash; im Fall von React also nur die eigenen Funktionen, die eigenen Hooks, die eigenen Helfer und die eigenen Effekte. NICHT testen sollten wir das Rendering von unserem JSX. Dass das sicher und verlässlich gerendert wird, ist Aufgabe von React, also sind auch die Tests dafür dem React-Team zu überlassen. Genau dasselbe gilt für Starndard-Hooks wie useState() oder useEffect().\nUnsere Aufgabe ist es aber, zu überprüfen, ob wir Reacts Standard-Werkzeuge richtig eingesetzt haben, und das heißt in der Regel, ob wir sie richtig kombiniert haben! Wenn wir mit Hilfe von Hooks z.B. ein Re-Rendering erzwungen haben, sollten wir prüfen, ob das Ergebnis auch tatsächlich unseren Erwartungen enspricht, auch dann, wenn wir wichtige Voraussetzungen ändern oder Spezialfälle checken müssen.\nHier helfen uns automatisierte Tests immens weiter!\n"},{"id":4,"href":"/react-signup/Reflexion/useState-and-useEffect/","title":"UseState braucht UseEffect","parent":"Reflexion","content":"   Beim Rumprobieren mit Ronas Version des Projektes kam es zu überraschenden Effekten: State-Variablen, die wir mit setX() upgedatet haben, hatten direkt nach dem Update immer noch ihren alten Wert:\nfunction changeHandler(event) { // alter Wert: \u0026#34;hi\u0026#34;  // target.value hat \u0026#34;his\u0026#34;  setFoo(event.target.value) // wird NICHT ausgefuehrt!  // OBWOHL foo jetzt eigentlich  // den Wert \u0026#34;his\u0026#34; haben muesste!  if (foo.length \u0026gt; 2) { changeButton() } } Das Problem ist, dass setFoo() asynchron ausgefuehrt wird. D.h. die If-Abfrage findet statt, während sich setFoo() in der \u0026ldquo;Warteschleife\u0026rdquo; befindet und das State-Update noch aussteht! Deshalb \u0026ldquo;passiert nix\u0026rdquo;.\nDie Lösung heißt useEffect(). Dieser Hook wird von React bekanntlich immer direkt nach einem Re-Rendering ausgeführt, und genau dort muessen wir die if-Abfrage platzieren:\nfunction MyComponent(props) { const [foo, setFoo] = useState(\u0026#39;\u0026#39;); // Siehe Erklaerung unten!  useEffect(() =\u0026gt; { if (foo.length \u0026gt; 2) { changeButton() } }[foo]); function changeHandler(event) { setFoo(event.target.value) } // ... } Jetzt wird die If-Abfrage DIREKT nach dem Re-Rendering ausgeführt, aber nur dann, wenn foo mit Hilfe von setFoo() einen neuen Wert bekommen hat. Das ist genau das, was wir wollen!\n"},{"id":5,"href":"/react-signup/Planung/","title":"Planung","parent":"Startseite","content":"Hier findet alles statt, was es zur Planung zu sagen gibt.\nDie eigentliche Planung findet auf dieser Seite statt, aber für die Erklärung dient diese Rubrik in der Dokumentation.\n"},{"id":6,"href":"/react-signup/","title":"Startseite","parent":"","content":"Dies hier ist die offizielle Dokumentation fuer dieses React-Projekt.\n"},{"id":7,"href":"/react-signup/tags/","title":"Tags","parent":"Startseite","content":""}]
[{"id":0,"href":"/react-signup/Berichte/","title":"Berichte","parent":"Startseite","content":"Hier finden sich alle Berichte über dieses Projekt in \u0026ldquo;chronologisch absteigender\u0026rdquo; Reihenfolge. Das heißt: Die aktuellsten Berichte sind ganz oben, die älteren weiter unten.\nDoku-Seite automatisieren    2021-12-16 06:50:    Ich habe mit Hilfe von Python invoke den Prozess automatisiert, neue Doku mit Hugo zu generieren und dann im Hauptprojekt hochzuladen. Das shutils package war dabei ausgesprochen nützlich und hilfreich.\nEinrichten der Doku-Seite    2021-12-15 07:51:    Ja, es ist mir gestern abend tatsächlich gelungen, Hauptprojekt und Doku-Projekt erfolgreich zusammen zu bringen. Nun sollte ich berichten, wie ich das geschafft habe (nach viel Try And Error):\n  Die Sammelwebsite https://mt-lampert.github.io/ einrichten wie in der offiziellen Dokumentation beschrieben. Das ist nötig, um der Dokumentation eine \u0026ldquo;Heimat\u0026rdquo; im Web zu geben.\n  Im Hauptprojekt den Ordner docs einrichten. Dort werden die statischen Webseiten der Dokumentation abgespeichert.\n  Im Hauptprojekt den Git-Branch DOKU anlegen. Der wird im weiteren Verlauf noch sehr wichtig werden.\n  Im Hauptprojekt Die Doku-Seite nach Anweisung der offiziellen Dokumentation anlegen.\n benutzter Branch: DOKU(deshalb wurde er eingerichtet) benutztes Verzeichnis: docs (deshalb wurde auch das eingerichtet)    Im Doku-Projekt die Dokumentation bis zur \u0026ldquo;ersten Veröffentlichungsreife\u0026rdquo; anlegen, committen und pushen.\n  Im Doku-Projekt folgende Änderung in config.toml vornehmen, committen und pushen:\nbaseURL = \u0026#39;https://mt-lampert.github.io/react-signup/\u0026#39; languageCode = \u0026#39;de-de\u0026#39; title = \u0026#39;React Signup Documentation\u0026#39; Damit werden beim Kompilieren alle internen Links auf die baseURL \u0026ldquo;geeicht\u0026rdquo; und kommen da an, wo man sie erwartet.\n  Die Dokumentation mit Hilfe von Hugo neu rendern:\n# alle moeglichen Altlasten vermeiden $ rm -rf public/* # rendern! $ hugo   Im Hauptprojekt in den Branch DOKU wechseln:\n$ git checkout -b DOKU   Im Hauptprojekt den Inhalt des public-Verzeichnisses aus dem Doku-Verzeichnis nach /docs kopieren:\n$ rm -rf docs/* $ cp -R -f ../react-signup-documentation/public/* docs/   committen und pushen.\n  Das Ergebnis im Browser überprüfen\n  Im Hauptprojekt den DOKU-Branch verlassen.\n  Erste Erfolgsmeldung    2021-12-14 \u0026ndash; 20:23    Es ist mir, glaube ich gelungen, Hauptprojekt und Doku-Projekt erfolgreich zusammen zu bringen. Macht mich sehr stolz und glücklich!\n"},{"id":1,"href":"/react-signup/Reflexion/","title":"Reflexion","parent":"Startseite","content":"Diese Rubrik dient der Erklärung, warum ich bestimmte Sachen so mache und so entscheide, wie ich es tue. Denn Dokumentation ist für mich beides: Werkstattbericht und Reflexion. Der Werkstattbericht klärt darüber auf, was ich wann getan habe, die Reflexion klärt auf, warum.\nIn diesem Sinne: Möge uns diese Seite uns allen zum Gewinn reichen!\n"},{"id":2,"href":"/react-signup/Reflexion/warum-test-driven/","title":"Warum Test-Driven Development?","parent":"Reflexion","content":"2021-12-19    Ganz einfach, weil man dadurch Zeit spart! Bei einem automatisierten Test kann man z.B. Formularfelder automatisch vom Test-Generator ausfüllen lassen, danach den Submit-Button automatisch klicken lassen und daraufhin das neu gerenderte Ergebnis testen.\nBeim nächsten Test kann man das Formular dann mit anderen Einträgen automatisch ausfüllen lassen, danach den Submit-Button wieder automatisch klicken lassen und daraufhin ein anderes neu gerendertes Ergebnis testen. Und deshalb will ich Zeit investieren, um diese Sorte Test zu lernen \u0026ndash; damit ich hinterher umso mehr Zeit einsparen kann.\nWas genau sollten wir testen?    Die goldene Regel besagt: Teste nur das, was du selber implementiert hast \u0026ndash; im Fall von React also nur die eigenen Funktionen, die eigenen Hooks, die eigenen Helfer und die eigenen Effekte. NICHT testen sollten wir das Rendering von unserem JSX. Dass das sicher und verlässlich gerendert wird, ist Aufgabe von React, also sind auch die Tests dafür dem React-Team zu überlassen. Genau dasselbe gilt für Starndard-Hooks wie useState() oder useEffect().\nUnsere Aufgabe ist es aber, zu überprüfen, ob wir Reacts Standard-Werkzeuge richtig eingesetzt haben, und das heißt in der Regel, ob wir sie richtig kombiniert haben! Wenn wir mit Hilfe von Hooks z.B. ein Re-Rendering erzwungen haben, sollten wir prüfen, ob das Ergebnis auch tatsächlich unseren Erwartungen enspricht, auch dann, wenn wir wichtige Voraussetzungen ändern oder Spezialfälle checken müssen.\nHier helfen uns automatisierte Tests immens weiter!\n"},{"id":3,"href":"/react-signup/Reflexion/useState-and-useEffect/","title":"UseState braucht UseEffect","parent":"Reflexion","content":"Beim Rumprobieren mit Ronas Version des Projektes kam es zu überraschenden Effekten: State-Variablen, die wir mit setX() upgedatet haben, hatten direkt nach dem Update immer noch ihren alten Wert:\nfunction changeHandler(event) { // alter Wert: \u0026#34;hi\u0026#34;  // target.value hat \u0026#34;his\u0026#34;  setFoo(event.target.value) // wird NICHT ausgefuehrt!  // OBWOHL foo jetzt eigentlich  // den Wert \u0026#34;his\u0026#34; haben muesste!  if (foo.length \u0026gt; 2) { changeButton() } } Das Problem ist, dass setFoo() asynchron ausgefuehrt wird. D.h. die If-Abfrage findet statt, während sich setFoo() in der \u0026ldquo;Warteschleife\u0026rdquo; befindet und das State-Update noch aussteht! Deshalb \u0026ldquo;passiert nix\u0026rdquo;.\nDie Lösung heißt useEffect(). Dieser Hook wird von React bekanntlich immer direkt nach einem Re-Rendering ausgeführt, und genau dort muessen wir die if-Abfrage platzieren:\nfunction MyComponent(props) { const [foo, setFoo] = useState(\u0026#39;\u0026#39;); // Siehe Erklaerung unten!  useEffect(() =\u0026gt; { if (foo.length \u0026gt; 2) { changeButton() } }[foo]); function changeHandler(event) { setFoo(event.target.value) } // ... } Jetzt wird die If-Abfrage DIREKT nach dem Re-Rendering ausgeführt, aber nur dann, wenn foo mit Hilfe von setFoo() einen neuen Wert bekommen hat. Das ist genau das, was wir wollen!\n"},{"id":4,"href":"/react-signup/Planung/","title":"Planung","parent":"Startseite","content":"Hier findet alles statt, was es zur Planung zu sagen gibt.\nDie eigentliche Planung findet auf dieser Seite statt, aber für die Erklärung dient diese Rubrik in der Dokumentation.\n"},{"id":5,"href":"/react-signup/","title":"Startseite","parent":"","content":"Dies hier ist die offizielle Dokumentation fuer dieses React-Projekt.\n"},{"id":6,"href":"/react-signup/tags/","title":"Tags","parent":"Startseite","content":""}]